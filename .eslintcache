[{"/Users/abraham/Data-structures-editor/src/index.js":"1","/Users/abraham/Data-structures-editor/src/App.js":"2","/Users/abraham/Data-structures-editor/src/utils/Utils.js":"3","/Users/abraham/Data-structures-editor/src/algorithms/Geometry.js":"4","/Users/abraham/Data-structures-editor/src/components/Canvas.js":"5","/Users/abraham/Data-structures-editor/src/utils/TextParser.js":"6","/Users/abraham/Data-structures-editor/src/utils/DataStructuresIdentifier.js":"7","/Users/abraham/Data-structures-editor/src/utils/CppIdentifier.js":"8","/Users/abraham/Data-structures-editor/src/algorithms/Buchheim.js":"9","/Users/abraham/Data-structures-editor/src/algorithms/red-black-tree/RedBlackTree.js":"10","/Users/abraham/Data-structures-editor/src/algorithms/red-black-tree/RedBlackTreeNode.js":"11","/Users/abraham/Data-structures-editor/src/algorithms/red-black-tree/TreeIterator.js":"12","/Users/abraham/Data-structures-editor/src/drawable-components/Text.js":"13","/Users/abraham/Data-structures-editor/src/drawable-components/Rectangle.js":"14","/Users/abraham/Data-structures-editor/src/data-structures/Indices.js":"15","/Users/abraham/Data-structures-editor/src/data-structures/STLIndices.js":"16","/Users/abraham/Data-structures-editor/src/data-structures/Vector.js":"17","/Users/abraham/Data-structures-editor/src/data-structures/Stack.js":"18","/Users/abraham/Data-structures-editor/src/data-structures/Deque.js":"19","/Users/abraham/Data-structures-editor/src/data-structures/Graph.js":"20","/Users/abraham/Data-structures-editor/src/data-structures/Matrix.js":"21","/Users/abraham/Data-structures-editor/src/data-structures/Trie.js":"22","/Users/abraham/Data-structures-editor/src/data-structures/STLSet.js":"23","/Users/abraham/Data-structures-editor/src/data-structures/Heap.js":"24","/Users/abraham/Data-structures-editor/src/data-structures/Queue.js":"25","/Users/abraham/Data-structures-editor/src/data-structures/STLMap.js":"26","/Users/abraham/Data-structures-editor/src/drawable-components/EmptyDataStructure.js":"27","/Users/abraham/Data-structures-editor/src/drawable-components/Edge.js":"28","/Users/abraham/Data-structures-editor/src/drawable-components/Node.js":"29"},{"size":152,"mtime":1671550730802,"results":"30","hashOfConfig":"31"},{"size":4453,"mtime":1673028986160,"results":"32","hashOfConfig":"31"},{"size":3484,"mtime":1673028954286,"results":"33","hashOfConfig":"31"},{"size":938,"mtime":1671550730800,"results":"34","hashOfConfig":"31"},{"size":2493,"mtime":1673028615912,"results":"35","hashOfConfig":"31"},{"size":14013,"mtime":1673027321131,"results":"36","hashOfConfig":"31"},{"size":1344,"mtime":1673025830113,"results":"37","hashOfConfig":"31"},{"size":1163,"mtime":1673026638072,"results":"38","hashOfConfig":"31"},{"size":7176,"mtime":1672938211974,"results":"39","hashOfConfig":"31"},{"size":13740,"mtime":1673027792211,"results":"40","hashOfConfig":"31"},{"size":796,"mtime":1672931176890,"results":"41","hashOfConfig":"31"},{"size":474,"mtime":1672930928209,"results":"42","hashOfConfig":"31"},{"size":383,"mtime":1672321593391,"results":"43","hashOfConfig":"31"},{"size":727,"mtime":1672245405362,"results":"44","hashOfConfig":"31"},{"size":1767,"mtime":1672933823564,"results":"45","hashOfConfig":"31"},{"size":4539,"mtime":1673028350268,"results":"46","hashOfConfig":"31"},{"size":1998,"mtime":1673028954231,"results":"47","hashOfConfig":"31"},{"size":1028,"mtime":1672931052656,"results":"48","hashOfConfig":"31"},{"size":304,"mtime":1672282740615,"results":"49","hashOfConfig":"31"},{"size":3671,"mtime":1673028954279,"results":"50","hashOfConfig":"31"},{"size":1489,"mtime":1673028954279,"results":"51","hashOfConfig":"31"},{"size":872,"mtime":1673028954235,"results":"52","hashOfConfig":"31"},{"size":190,"mtime":1672788116762,"results":"53","hashOfConfig":"31"},{"size":2989,"mtime":1673028954243,"results":"54","hashOfConfig":"31"},{"size":219,"mtime":1672321716243,"results":"55","hashOfConfig":"31"},{"size":3638,"mtime":1673028954270,"results":"56","hashOfConfig":"31"},{"size":351,"mtime":1672245291807,"results":"57","hashOfConfig":"31"},{"size":3588,"mtime":1672237458260,"results":"58","hashOfConfig":"31"},{"size":2816,"mtime":1672929740118,"results":"59","hashOfConfig":"31"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},"10hd212",{"filePath":"63","messages":"64","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"65","messages":"66","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"62"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"62"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81","usedDeprecatedRules":"62"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"86","usedDeprecatedRules":"62"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"107","messages":"108","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"109","messages":"110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"111","messages":"112","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"113","messages":"114","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"115","messages":"116","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"117","messages":"118","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"119","messages":"120","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"121","usedDeprecatedRules":"62"},{"filePath":"122","messages":"123","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},"/Users/abraham/Data-structures-editor/src/index.js",[],["124","125"],"/Users/abraham/Data-structures-editor/src/App.js",["126"],"/Users/abraham/Data-structures-editor/src/utils/Utils.js",["127"],"/Users/abraham/Data-structures-editor/src/algorithms/Geometry.js",[],"/Users/abraham/Data-structures-editor/src/components/Canvas.js",["128","129","130","131","132","133"],"import React, { useState, useCallback, useThrottled, useEffect } from \"react\";\nimport Rectangle from \"../drawable-components/Rectangle\";\n\nconst MAX_ZOOM = 4;\nconst MIN_ZOOM = 0.3;\nconst ZOOM_INCREMENT = 0.25;\n\nexport default function Canvas({ objects }) {\n  const [zoom, setZoom] = useState(1.5);\n  const [dragging, setDragging] = useState(false);\n  const [top, setTop] = useState(0);\n  const [left, setLeft] = useState(50);\n  const [relativeTop, setRelativeTop] = useState(0);\n  const [relativeLeft, setRelativeLeft] = useState(0);\n  const [windowWidth, setWindowWidth] = useState(Number(window.innerWidth));\n  const [windowHeight, setWindowHeight] = useState(Number(window.innerHeight));\n\n  const zoomInOutMouseWheel = useCallback((e) => {\n    const newzoom = zoom - e.deltaY * 0.001;\n    setZoom(Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, newzoom)));\n  }, [zoom]);\n\n  const mouseDown = useCallback((e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    if (e.button !== 0) {\n      return; // Should only run code from left mouse click\n    }\n    // console.log(\"mouseDown\", e.pageX, e.pageY, e);\n    setDragging(true);\n    setRelativeLeft(e.pageX - left);\n    setRelativeTop(e.pageY - top);\n  }, [left, top]);\n\n  const mouseUp = useCallback((e) => {\n    // console.log(\"mouseUp\");\n    e.stopPropagation();\n    e.preventDefault();\n    setDragging(false);\n  }, []);\n\n  const moveMouse = useCallback((e) => {\n    // console.log(\"moveMouse\");\n    e.stopPropagation();\n    e.preventDefault();\n    if (!dragging) {\n      return;\n    }\n    setLeft(e.pageX - relativeLeft);\n    setTop(e.pageY - relativeTop);\n  }, [dragging]);\n\n  useEffect(() => {\n    // console.log(left, top, dragging);\n\n    document.addEventListener('mousemove', moveMouse);\n    document.addEventListener('mouseup', mouseUp);\n    // window.addEventListener('resize', updateWindowDimensions);\n    return () => {\n      document.removeEventListener('mousemove', moveMouse);\n      document.removeEventListener('mouseup', mouseUp);\n      // window.removeEventListener('resize', updateWindowDimensions);\n    };\n  }, [moveMouse, mouseUp, mouseDown]);\n\n  return (\n    <div className=\"scrollable-image\">\n      <svg className=\"image\"\n        viewBox={`${-left} ${-top} ${windowWidth} ${windowHeight}`}\n        onWheel={zoomInOutMouseWheel}\n        onMouseDown={mouseDown}\n        onMouseUp={mouseUp}\n        onMouseMove={moveMouse}>\n        <g transform={`scale(${zoom})`}>\n          {objects}\n        </g>\n      </svg>\n    </div>\n  );\n}","/Users/abraham/Data-structures-editor/src/utils/TextParser.js",["134","135"],"import { isColor, divideByTokens, isSmaller, getColor } from \"./Utils\";\nimport { VERTICAL_DISTANCE, BLOCK_HEIGHT } from \"./Utils\"\n\nimport { Graph } from \"../data-structures/Graph\";\nimport { Trie } from \"../data-structures/Trie\";\nimport { Sides, Vector } from \"../data-structures/Vector\";\nimport { Matrix } from \"../data-structures/Matrix\";\nimport { Stack } from \"../data-structures/Stack\";\nimport { Queue } from \"../data-structures/Queue\";\nimport { Deque } from \"../data-structures/Deque\";\nimport { Heap, HeapType } from \"../data-structures/Heap\";\nimport { STLSet } from \"../data-structures/STLSet\";\nimport { STLMap, LastAction } from \"../data-structures/STLMap\";\n\nimport { Indices } from \"../data-structures/Indices\";\nimport { STLIndices } from \"../data-structures/STLIndices\";\n\nimport { DataStructuresIdentifier } from \"./DataStructuresIdentifier\";\nimport { CppIdentifier } from \"./CppIdentifier\";\n\nexport class TextParser {\n  constructor(text, oldParser = null) {\n    const lines = text.split('\\n').filter((line) => {\n      return line.length > 0;\n    });\n\n    this.textObjects = this.splitInTextObjects(lines);\n\n    this.objects = [];\n    this.lastTop = 0;\n    let objectCount = new Map();\n    this.textObjects.forEach((element, index) => {\n      let object = this.getObject(element, null);\n      this.lastTop += object.height;\n      this.lastTop += VERTICAL_DISTANCE;\n\n      if (element.name) {\n        object.name = element.name;\n      } else {\n        const id = (objectCount.get(object.name) ?? 0) + 1;\n        objectCount.set(object.name, id);\n        object.name += \" \" + id;\n      }\n\n      this.objects.push(object);\n\n      // add indices if is a vector, array or matrix\n      if (DataStructuresIdentifier.isVector(element.type) ||\n        DataStructuresIdentifier.isMatrix(element.type)) {\n        this.objects.push(new Indices(element.type, object));\n      }\n\n      // add top, bottom, front, back, begin, end if it is a stack, queue, deque, heap, set, map\n      if (DataStructuresIdentifier.isStack(element.type) ||\n        DataStructuresIdentifier.isQueue(element.type) ||\n        DataStructuresIdentifier.isDeque(element.type) ||\n        DataStructuresIdentifier.isHeap(element.type) ||\n        DataStructuresIdentifier.isSet(element.type) ||\n        DataStructuresIdentifier.isMap(element.type)) {\n        this.objects.push(new STLIndices(element.type, object));\n      }\n    });\n  }\n\n  getObject(element, previousObject = null) {\n    if (DataStructuresIdentifier.isVector(element.type)) {\n      return this.getVector(element.lines);\n    } else if (DataStructuresIdentifier.isMatrix(element.type)) {\n      return this.getMatrix(element.lines);\n    } else if (DataStructuresIdentifier.isStack(element.type)) {\n      return this.getStack(element.lines);\n    } else if (DataStructuresIdentifier.isQueue(element.type)) {\n      return this.getQueue(element.lines);\n    } else if (DataStructuresIdentifier.isDeque(element.type)) {\n      return this.getDeque(element.lines);\n    } else if (DataStructuresIdentifier.isHeap(element.type)) {\n      return this.getHeap(element.lines);\n    } else if (DataStructuresIdentifier.isSet(element.type)) {\n      return this.getSet(element.lines);\n    } if (DataStructuresIdentifier.isMap(element.type)) {\n      return this.getMap(element.lines);\n    } if (DataStructuresIdentifier.isGraph(element.type)) {\n      return this.getGraph(element.lines, null);\n    } else if (DataStructuresIdentifier.isTrie(element.type)) {\n      return this.getTrie(element.lines);\n    }\n    return null;\n  }\n\n  getNameIfAny(line) {\n    let tokens = divideByTokens(line);\n    tokens.shift();\n    return tokens.join(\" \");\n  }\n\n  splitInTextObjects(lines) {\n    // Objets are in the form [{ object type, lines of text }]\n    let objects = [];\n    let start = -1;\n    for (let pos = 0; pos <= lines.length; pos++) {\n      if (pos === lines.length || DataStructuresIdentifier.isObject(lines[pos])) {\n        if (start !== -1) {\n          objects.push({\n            type: divideByTokens(lines[start].toLowerCase()).shift(),\n            name: this.getNameIfAny(lines[start]),\n            lines: lines.slice(start + 1, pos).map((line) => {\n              return divideByTokens(line);\n            }),\n          });\n        }\n        start = pos;\n      }\n    }\n    return objects;\n  }\n\n  getVector(lines) {\n    const vector = new Vector(this.lastTop);\n\n    let sortArray = false;\n    let reverseArray = false;\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        vector.currentColor = getColor(line[0]);\n        continue;\n      }\n\n      for (const element of line) {\n        if (CppIdentifier.isSort(element)) {\n          sortArray = true;\n        } else if (CppIdentifier.isReverse(element)) {\n          reverseArray = !reverseArray;\n        } else if (isColor(element)) {\n          // update color of the last element if any\n          vector.updateLastElementColor(getColor(element));\n        } else if (CppIdentifier.isPushBack(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPopBack(element)) {\n          vector.popBack();\n        } else {\n          vector.pushBack(element);\n        }\n      }\n    }\n\n    if (sortArray) {\n      vector.data.sort((a, b) => isSmaller(a.value, b.value));\n    }\n\n    if (reverseArray) {\n      vector.data.reverse();\n    }\n\n    return vector;\n  }\n\n  getMatrix(lines) {\n    const matrix = new Matrix(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        matrix.currentColor = getColor(line[0]);\n        continue;\n      }\n\n      let newRowAdded = false;\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          matrix.updateLastElementColor(getColor(element));\n        } else {\n          if (!newRowAdded) {\n            matrix.addRow();\n            newRowAdded = true;\n          }\n          matrix.lastRowPushBack(element);\n        }\n      }\n    }\n\n    if (matrix.empty()) {\n      matrix.height = BLOCK_HEIGHT;\n    }\n\n    return matrix;\n  }\n\n  getQueue(lines) {\n    const queue = new Queue(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        queue.currentColor = getColor(line[0]);\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          queue.updateLastElementColor(getColor(element));\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPop(element)) {\n          queue.pop();\n        } else {\n          queue.push(element);\n        }\n      }\n    }\n\n    return queue;\n  }\n\n  getStack(lines) {\n    const stack = new Stack(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        stack.currentColor = getColor(line[0]);\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          stack.updateLastElementColor(getColor(element));\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isPop(element)) {\n          stack.pop();\n        } else {\n          stack.push(element);\n        }\n      }\n    }\n\n    stack.updateHeight();\n\n    return stack;\n  }\n\n  getDeque(lines) {\n    const deque = new Deque(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        deque.currentColor = getColor(line[0]);\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          deque.updateLastElementColor(getColor(element));\n        } else if (CppIdentifier.isPushBack(element)) {\n          deque.side = Sides.BACK;\n        } else if (CppIdentifier.isPushFront(element)) {\n          deque.side = Sides.FRONT;\n        } else if (CppIdentifier.isPopBack(element)) {\n          deque.popBack();\n        } else if (CppIdentifier.isPopFront(element)) {\n          deque.popFront();\n        } else {\n          deque.push(element);\n        }\n      }\n    }\n\n    return deque;\n  }\n\n  getHeap(lines) {\n    const heap = new Heap(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        heap.currentColor = getColor(line[0]);\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          heap.updateLastElementColor(getColor(element));\n        } else if (CppIdentifier.isPop(element)) {\n          heap.pop();\n        } else if (CppIdentifier.isPush(element)) {\n          // ignore this word :p\n          continue;\n        } else if (CppIdentifier.isMax(element)) {\n          heap.heapType = HeapType.MAX;\n        } else if (CppIdentifier.isMin(element)) {\n          heap.heapType = HeapType.MIN;\n        } else {\n          heap.push(element);\n        }\n      }\n    }\n\n    heap.updateHeight();\n\n    return heap;\n  }\n\n  getSet(lines) {\n    const set = new STLSet(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        set.currentColor = getColor(line[0]);\n        continue;\n      }\n\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          set.updateLastElementColor(getColor(element));\n        } else if (CppIdentifier.isErase(element)) {\n          set.lastAction = LastAction.ERASE;\n        } else if (CppIdentifier.isInsert(element)) {\n          set.lastAction = LastAction.INSERT;\n        } else if (CppIdentifier.asArray(element)) {\n          set.asArray = true;\n        } else if (CppIdentifier.asTree(element)) {\n          set.asArray = false;\n        }else {\n          if (set.lastAction === LastAction.INSERT) {\n            set.insert(element);\n          } else {\n            set.erase(element);\n          }\n          // reset set to insert as default\n          set.lastAction = LastAction.INSERT;\n        }\n      }\n    }\n\n    set.updateHeight();\n\n    return set;\n  }\n\n  getMap(lines) {\n    const map = new STLMap(this.lastTop);\n\n    for (const line of lines) {\n      if (line.length === 1 && isColor(line[0])) {\n        map.currentColor = getColor(line[0]);\n        continue;\n      }\n\n      let key = null;\n      let value = null;\n      for (const element of line) {\n        if (isColor(element)) {\n          // update color of the last element if any\n          map.updateLastElementColor(getColor(element));\n        } else if (CppIdentifier.isErase(element)) {\n          map.lastAction = LastAction.ERASE;\n        } else if (CppIdentifier.isInsert(element)) {\n          map.lastAction = LastAction.INSERT;\n        } else if (CppIdentifier.asArray(element)) {\n          map.asArray = true;\n        } else if (CppIdentifier.asTree(element)) {\n          map.asArray = false;\n        } else {\n          if (map.lastAction === LastAction.INSERT) {\n            if (key === null) {\n              key = element;\n            } else if (key !== null) {\n              value = element;\n              map.insert(key, value);\n              key = null;\n              value = null;\n            }\n          } else {\n            map.erase(element);\n            key = null;\n            value = null;\n          }\n          // reset map to insert as default\n          map.lastAction = LastAction.INSERT;\n        }\n      }\n    }\n\n    map.updateHeight();\n\n    return map;\n  }\n\n  // getGraph(lines, previousGraph) {\n  //   const graph = new Graph(false, previousGraph);\n\n  //   for (const line of lines) {\n  //     if (line.length === 1) {\n  //       const x = line[0];\n  //       if (isColor(x)) {\n  //         // paint everything that's below with this color\n  //         graph.currentNodeColor = x;\n  //       } else {\n  //         // Single node\n  //         const u = line[0];\n  //         graph.addNode(u, {});\n  //       }\n  //     } else if (line.length === 2) {\n  //       const u = line[0];\n  //       const x = line[1];\n  //       if (isColor(x)) {\n  //         // Node with color x\n  //         graph.addNode(u, { color: x });\n  //       } else {\n  //         // Edge u -> v (depends on the flag)\n  //         const v = line[1];\n  //         graph.addEdge(u, v, \"\");\n  //       }\n  //     } else if (line.length >= 3) {\n  //       const u = line[0];\n  //       const v = line[1];\n\n  //       // Edge u -> v with color | weight | dash\n  //       let weight = \"\";\n  //       let color = \"black\";\n  //       let dashedLine = false;\n  //       for (let i = 2; i < line.length; i++) {\n  //         const x = line[i];\n  //         if (isColor(x)) {\n  //           color = x;\n  //         } else if (isDash(x)) {\n  //           dashedLine = true;\n  //         } else {\n  //           weight += x + \" \";\n  //         }\n  //       }\n\n  //       graph.addEdge(u, v, weight, color, dashedLine);\n  //     }\n  //   }\n\n  //   return graph;\n  // }\n\n  // getTrie(lines) {\n  //   const trie = new Trie(addNode, addEdge);\n  //   currentNodeColor = \"red\";\n  //   for (const line of lines) {\n  //     if (object.length === 1) {\n  //       if (isColor(object[0])) {\n  //         // change the color of all below nodes\n  //         currentNodeColor = object[0];\n  //       } else {\n  //         // insert a word with the currentNodeColor\n  //         const word = object[0];\n  //         trie.insert(word, currentNodeColor);\n  //       }\n  //     } else if (object.length === 2) {\n  //       // insert a word with possibly a custom color\n  //       const word = object[0];\n  //       let color = currentNodeColor;\n  //       if (object.length === 2 && isColor(object[1])) {\n  //         color = object[1];\n  //       }\n  //       trie.insert(word, color);\n  //     }\n  //   }\n  //   trie.dfs(trie.root, \"*\");\n  // }\n}","/Users/abraham/Data-structures-editor/src/utils/DataStructuresIdentifier.js",[],"/Users/abraham/Data-structures-editor/src/utils/CppIdentifier.js",[],"/Users/abraham/Data-structures-editor/src/algorithms/Buchheim.js",["136","137","138","139","140"],"// Reference of the algorithm: https://llimllib.github.io/pymag-trees/\n\nimport { VERTICAL_DISTANCE, HORIZONTAL_DISTANCE } from \"../utils/Utils\";\n\nconst States = {\n  UNVISITED: -1,\n  DFS_TREE: 0,\n  ASSIGN_EXTRA_VARIABLES: 1,\n  APPLY_BUCHHEIM: 2,\n  GET_TREE_RANGE: 3,\n  MOVE_TREE: 4,\n}\n\nfunction findDfsTree(node, parent = undefined, depth = 0) {\n  node.vis = States.DFS_TREE;\n  for (let child of node.children)\n    if (child.vis !== States.DFS_TREE) {\n      node.dfsTreeChildren.push(child);\n      findDfsTree(child, node, depth + 1);\n    }\n}\n\nfunction assign(node, parent = undefined, depth = 0, pos = 1) {\n  node.vis = States.ASSIGN_EXTRA_VARIABLES;\n  node.x = 0;\n  node.y = depth * VERTICAL_DISTANCE;\n  node.parent = parent;\n  node.thread = undefined;\n  node.offset = 0;\n  node.ancestor = node;\n  node.change = 0;\n  node.shift = 0;\n  node.leftmost = undefined;\n  node.pos = pos;\n  let i = 1;\n  for (let child of node.children)\n    if (child.vis !== States.ASSIGN_EXTRA_VARIABLES) {\n      assign(child, node, depth + 1, i++);\n    }\n}\n\nfunction left(node) {\n  return node.thread || (node.children.length && node.children[0]);\n}\n\nfunction right(node) {\n  return node.thread || (node.children.length && node.children[node.children.length - 1]);\n}\n\nfunction leftBrother(node) {\n  if (node.parent === undefined)\n    return undefined;\n  let bro = undefined;\n  for (let child of node.parent.children) {\n    if (child === node) break;\n    bro = child;\n  }\n  return bro;\n}\n\nfunction leftmostSibling(node) {\n  if (node.leftmost === undefined && node.parent && node !== node.parent.children[0]) {\n    node.leftmost = node.parent.children[0];\n  }\n  return node.leftmost;\n}\n\nfunction noChildrenLeft(node) {\n  for (let child of node.children)\n    if (child.vis === States.ASSIGN_EXTRA_VARIABLES)\n      return false;\n  return true;\n}\n\nfunction buchheim(node) {\n  node.vis = States.APPLY_BUCHHEIM;\n  if (noChildrenLeft(node)) {\n    if (leftmostSibling(node)) {\n      node.x = leftBrother(node).x + HORIZONTAL_DISTANCE;\n    } else {\n      node.x = 0;\n    }\n  } else {\n    let defaultAncestor = node.children[0];\n    for (let child of node.children)\n      if (child.vis !== States.APPLY_BUCHHEIM) {\n        buchheim(child);\n        defaultAncestor = apportion(child, defaultAncestor);\n      }\n    executeShifts(node);\n    const mid = (node.children[0].x + node.children[node.children.length - 1].x) / 2;\n    const bro = leftBrother(node);\n    if (bro) {\n      node.x = bro.x + HORIZONTAL_DISTANCE;\n      node.offset = node.x - mid;\n    } else {\n      node.x = mid;\n    }\n  }\n}\n\nfunction apportion(node, defaultAncestor) {\n  const w = leftBrother(node);\n  if (w !== undefined && w !== node) {\n    let vir = node;\n    let vor = node;\n    let vil = w;\n    let vol = leftmostSibling(node);\n    let sir = node.offset;\n    let sor = node.offset;\n    let sil = vil.offset;\n    let sol = vol.offset;\n    while (right(vil) && left(vir)) {\n      vil = right(vil);\n      vir = left(vir);\n      vol = left(vol);\n      vor = right(vor);\n      vor.ancestor = node;\n      let shift = (vil.x + sil) - (vir.x + sir) + HORIZONTAL_DISTANCE;\n      if (shift > 0) {\n        moveSubtree(ancestor(vil, node, defaultAncestor), node, shift);\n        sir = sir + shift;\n        sor = sor + shift;\n      }\n      sil += vil.offset;\n      sir += vir.offset;\n      sol += vol.offset;\n      sor += vor.offset;\n    }\n    if (right(vil) && !right(vor)) {\n      vor.thread = right(vil);\n      vor.offset += sil - sor;\n    } else {\n      if (left(vir) && !left(vol)) {\n        vol.thread = left(vir);\n        vol.offset += sir - sol;\n      }\n      defaultAncestor = node;\n    }\n  }\n  return defaultAncestor;\n}\n\nfunction moveSubtree(wl, wr, shift) {\n  if (wl !== undefined && wr !== undefined) {\n    let subtrees = wr.pos - wl.pos;\n    wr.change -= shift / subtrees;\n    wr.shift += shift;\n    wl.change += shift / subtrees;\n    wr.x += shift;\n    wr.offset += shift;\n  }\n}\n\nfunction executeShifts(node) {\n  let shift = 0;\n  let change = 0;\n  for (let i = node.children.length - 1; i >= 0; i--) {\n    let child = node.children[i];\n    child.x += shift;\n    child.offset += shift;\n    change += child.change;\n    shift += child.shift + change;\n  }\n}\n\nfunction ancestor(vil, node, defaultAncestor) {\n  if (node.parent === undefined)\n    return defaultAncestor;\n  const isChild = node.parent.children.includes((node) => {\n    return node.id === vil.ancestor.id;\n  });\n  return isChild ? vil.ancestor : defaultAncestor;\n}\n\nfunction getTreeRange(node, m = HORIZONTAL_DISTANCE, depth = 1) {\n  node.x += m;\n  node.vis = States.GET_TREE_RANGE;\n\n  let treeRange = {\n    mn: node.x,\n    mx: node.x\n  };\n\n  for (let child of node.children)\n    if (child.vis !== States.GET_TREE_RANGE) {\n      let childTreeRange = getTreeRange(child, m + node.offset, depth + 1);\n      treeRange.mn = Math.min(treeRange.mn, childTreeRange.mn);\n      treeRange.mx = Math.max(treeRange.mx, childTreeRange.mx);\n    }\n  // console.log(node.id, treeRange);\n\n  return treeRange;\n}\n\nfunction moveTree(node, mn) {\n  node.x += mn;\n  node.vis = States.MOVE_TREE;\n  for (let child of node.children)\n    if (child.vis !== States.MOVE_TREE) {\n      moveTree(child, mn);\n    }\n}\n\nexport function prettify(graph) {\n  const byLabel = (a, b) => {\n    if (a.label < b.label)\n      return -1;\n    if (a.label > b.label)\n      return 1;\n    return 0;\n  }\n\n  // let tmpNodes = [];\n  for (let [node, values] of graph.nodes) {\n    // let index = tmpNodes.push({\n    //   label: values.label,\n    // });\n    graph.nodes.set(node, {\n      ...values,\n      children: [],\n      dfsTreeChildren: [],\n      vis: States.UNVISITED,\n    });\n  }\n\n  // add edges to the tree\n  for (let [edge, values] of graph.edges) {\n    const fromNode = graph.nodes.get(edge.from);\n    const toNode = graph.nodes.get(edge.to);\n    fromNode.children.push(toNode);\n    toNode.children.push(fromNode);\n  }\n\n  // find the dfs tree\n  for (let [node, nodeData] of graph.nodes) {\n    if (nodeData.vis === States.UNVISITED)\n      findDfsTree(nodeData);\n  }\n\n  // change the children with the dfsTreeChildren\n  for (let [node, nodeData] of graph.nodes) {\n    nodeData.children = nodeData.dfsTreeChildren;\n    delete nodeData.dfsTreeChildren;\n  }\n\n  // algorithm of buchheim for a pretty tree\n  let sum = 0;\n  for (let [node, nodeData] of graph.nodes) {\n    if (nodeData.vis === States.DFS_TREE) {\n      assign(nodeData);\n      buchheim(nodeData);\n\n      // define the current tree range\n      let treeRange = getTreeRange(nodeData);\n      let width = treeRange.mx - treeRange.mn;\n      // console.log(treeRange, width);\n\n      if (width >= 0) {\n        moveTree(nodeData, sum);\n        sum += width;\n      }\n      sum += HORIZONTAL_DISTANCE;\n    }\n  }\n}\n\n// export function getComponentFrom(startingNodeId, nodes, edges) {\n//   addEdgesToTheList(nodes, edges);\n\n//   let component = new Set();\n\n//   function dfs(node) {\n//     component.add(node.id);\n//     node.vis = 1;\n//     for (let child of node.children)\n//       if (child.vis === -1) {\n//         dfs(child);\n//       }\n//   }\n\n//   let startingNode = nodes.find((node) => node.id === startingNodeId);\n//   dfs(startingNode);\n\n//   return component;\n// }","/Users/abraham/Data-structures-editor/src/algorithms/red-black-tree/RedBlackTree.js",[],"/Users/abraham/Data-structures-editor/src/algorithms/red-black-tree/RedBlackTreeNode.js",["141"],"'use strict';\n\n/**\n * Node of the red black tree\n * constructor\n * param key : Number\n * param value : Object\n * param left : Node\n * param right : Node\n * param color : Number\n */\n\nexport const NodeColor = {\n  RED: 0,\n  BLACK: 1\n}\n\nexport class RedBlackTreeNode {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.color = null;\n    this.parent = null;\n  }\n\n  /**\n  * return Boolean\n  */\n  isRed() {\n    return this.color === NodeColor.RED\n  }\n\n  getValue() {\n    return {\n      key: this.key,\n      value: this.value,\n    }\n  }\n}\n\nexport function isNilNode(node) {\n  return node == null || (node.key == null && node.value == null\n    && node.color === NodeColor.BLACK\n    && node.left == null && node.right == null);\n}\n","/Users/abraham/Data-structures-editor/src/algorithms/red-black-tree/TreeIterator.js",[],"/Users/abraham/Data-structures-editor/src/drawable-components/Text.js",[],"/Users/abraham/Data-structures-editor/src/drawable-components/Rectangle.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/Indices.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/STLIndices.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/Vector.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/Stack.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/Deque.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/Graph.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/Matrix.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/Trie.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/STLSet.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/Heap.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/Queue.js",[],"/Users/abraham/Data-structures-editor/src/data-structures/STLMap.js",["142","143"],"/Users/abraham/Data-structures-editor/src/drawable-components/EmptyDataStructure.js",[],"/Users/abraham/Data-structures-editor/src/drawable-components/Edge.js",["144","145"],"import React from \"react\"\nimport { NaturalCurve } from \"react-svg-curve\"\nimport { length, dif, sum, mul, divide, unit, perp, rotate, projectionOnCircle } from \"../algorithms/Geometry\";\n\nexport function Edge({ rank, from, to, weight, color, directed, dashedLine }) {\n  const radius = 25;\n\n  let bothEndpoints = (from !== undefined && to !== undefined);\n  let midPoint = { x: 0, y: 0 };\n  let fromOnCircle = { x: 0, y: 0 };\n  let toOnCircle = { x: 0, y: 0 };\n\n  if (bothEndpoints) {\n    let half = divide(sum(from, to), 2);\n    let dirHalfPerp = unit(perp(dif(from, half)))\n    midPoint = sum(half, mul(dirHalfPerp, -40 * rank));\n\n    fromOnCircle = projectionOnCircle(from, radius, midPoint);\n    toOnCircle = projectionOnCircle(to, radius, midPoint);\n  }\n\n  function getArrow() {\n    let dir = unit(dif(midPoint, toOnCircle));\n\n    // let p = sum(toOnCircle, mul(dir, radius));\n    let start = toOnCircle;\n    let end = sum(toOnCircle, mul(dir, 10));\n    let perpQ = unit(perp(dif(start, end)));\n    let perp1 = sum(end, mul(perpQ, 5));\n    let perp2 = sum(end, mul(perpQ, -5));\n\n    let str =\n      \" M \" + start.x + \",\" + start.y +\n      \" \" + perp1.x + \", \" + perp1.y +\n      \" \" + perp2.x + \" \" + perp2.y + \" z \";\n    // console.log(str);\n\n    return str;\n  }\n\n  const boldEdge = (color === \"black\" ? 1.5 : 3);\n  const dash = dashedLine ? 5 : 0;\n\n  return (\n    <g>\n      {\n        bothEndpoints &&\n        <NaturalCurve\n          data={[\n            [fromOnCircle.x, fromOnCircle.y],\n            [midPoint.x, midPoint.y],\n            [toOnCircle.x, toOnCircle.y],\n          ]}\n          stroke={color}\n          strokeWidth={boldEdge}\n          strokeDasharray={dash}\n          showPoints={false} />\n      }\n\n      {\n        (bothEndpoints && directed) &&\n        <path\n          d={getArrow()}\n          fill={color}\n          stroke={color} />\n      }\n\n      {\n        (bothEndpoints && weight) &&\n        <text\n          x={midPoint.x + 10}\n          y={midPoint.y + 10}\n          fill=\"black\" >\n          {weight}\n        </text>\n      }\n    </g>\n  );\n}\n\nexport function Loop({ from, to, weight, color, directed }) {\n  let bothEndpoints = (from !== undefined && to !== undefined);\n\n  let textPos = { x: 0, y: 0 };\n  if (bothEndpoints) {\n    textPos.x = (from.x + to.x) / 2;\n    textPos.y = (from.y + to.y) / 2;\n  }\n\n  const boldEdge = (color === \"black\" ? 1.5 : 3);\n  const dx = 0;\n  const dy = -35;\n\n  function getArrow() {\n    let loopOutside = {\n      x: from.x + 20,\n      y: from.y + dy\n    };\n\n    let dir = unit(dif(loopOutside, from));\n\n    let p = {\n      x: loopOutside.x - 5.5,\n      y: loopOutside.y + 13.5\n    };\n    let q = sum(p, mul(dir, 8));\n\n    let perpQ = unit(perp(dif(p, q)));\n    let perp1 = sum(q, mul(perpQ, 5));\n    let perp2 = sum(q, mul(perpQ, -5));\n\n    let str =\n      \" M \" + p.x + \",\" + p.y +\n      \" \" + perp1.x + \", \" + perp1.y +\n      \" \" + perp2.x + \" \" + perp2.y + \" z \";\n    // console.log(str);\n\n    return str;\n  }\n\n  console.log(from.x, from.y);\n\n  return (\n    <g>\n      {\n        bothEndpoints &&\n        <circle\n          cx={from.x + dx}\n          cy={from.y + dy}\n          r={20}\n          fill=\"none\"\n          stroke={color}\n          strokeWidth={boldEdge}\n        />\n      }\n\n      {\n        (bothEndpoints && directed) &&\n        <path\n          d={getArrow()}\n          fill={color}\n          stroke={color} />\n      }\n\n      {\n        (bothEndpoints && weight) &&\n        <text\n          x={textPos.x + dx}\n          y={textPos.y + 1.8 * dy}\n          fill=\"black\" >\n          {weight}\n        </text>\n      }\n    </g>\n  );\n}","/Users/abraham/Data-structures-editor/src/drawable-components/Node.js",[],{"ruleId":"146","replacedBy":"147"},{"ruleId":"148","replacedBy":"149"},{"ruleId":"150","severity":1,"message":"151","line":181,"column":6,"nodeType":"152","endLine":181,"endColumn":12,"suggestions":"153"},{"ruleId":"154","severity":1,"message":"155","line":90,"column":22,"nodeType":"156","messageId":"157","endLine":90,"endColumn":23,"suggestions":"158"},{"ruleId":"159","severity":1,"message":"160","line":1,"column":40,"nodeType":"161","messageId":"162","endLine":1,"endColumn":52},{"ruleId":"159","severity":1,"message":"163","line":2,"column":8,"nodeType":"161","messageId":"162","endLine":2,"endColumn":17},{"ruleId":"159","severity":1,"message":"164","line":6,"column":7,"nodeType":"161","messageId":"162","endLine":6,"endColumn":21},{"ruleId":"159","severity":1,"message":"165","line":15,"column":23,"nodeType":"161","messageId":"162","endLine":15,"endColumn":37},{"ruleId":"159","severity":1,"message":"166","line":16,"column":24,"nodeType":"161","messageId":"162","endLine":16,"endColumn":39},{"ruleId":"150","severity":1,"message":"167","line":51,"column":6,"nodeType":"152","endLine":51,"endColumn":16,"suggestions":"168"},{"ruleId":"159","severity":1,"message":"169","line":4,"column":10,"nodeType":"161","messageId":"162","endLine":4,"endColumn":15},{"ruleId":"159","severity":1,"message":"170","line":5,"column":10,"nodeType":"161","messageId":"162","endLine":5,"endColumn":14},{"ruleId":"159","severity":1,"message":"171","line":206,"column":9,"nodeType":"161","messageId":"162","endLine":206,"endColumn":16},{"ruleId":"159","severity":1,"message":"172","line":228,"column":19,"nodeType":"161","messageId":"162","endLine":228,"endColumn":25},{"ruleId":"159","severity":1,"message":"173","line":236,"column":13,"nodeType":"161","messageId":"162","endLine":236,"endColumn":17},{"ruleId":"159","severity":1,"message":"173","line":242,"column":13,"nodeType":"161","messageId":"162","endLine":242,"endColumn":17},{"ruleId":"159","severity":1,"message":"173","line":249,"column":13,"nodeType":"161","messageId":"162","endLine":249,"endColumn":17},{"ruleId":"174","severity":1,"message":"175","line":1,"column":1,"nodeType":"176","messageId":"177","endLine":1,"endColumn":14,"fix":"178"},{"ruleId":"159","severity":1,"message":"179","line":2,"column":10,"nodeType":"161","messageId":"162","endLine":2,"endColumn":29},{"ruleId":"159","severity":1,"message":"180","line":4,"column":39,"nodeType":"161","messageId":"162","endLine":4,"endColumn":46},{"ruleId":"159","severity":1,"message":"181","line":3,"column":10,"nodeType":"161","messageId":"162","endLine":3,"endColumn":16},{"ruleId":"159","severity":1,"message":"182","line":3,"column":53,"nodeType":"161","messageId":"162","endLine":3,"endColumn":59},"no-native-reassign",["183"],"no-negated-in-lhs",["184"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'parser'. Either include it or remove the dependency array.","ArrayExpression",["185"],"no-useless-escape","Unnecessary escape character: \\..","Literal","unnecessaryEscape",["186","187"],"no-unused-vars","'useThrottled' is defined but never used.","Identifier","unusedVar","'Rectangle' is defined but never used.","'ZOOM_INCREMENT' is assigned a value but never used.","'setWindowWidth' is assigned a value but never used.","'setWindowHeight' is assigned a value but never used.","React Hook useCallback has missing dependencies: 'relativeLeft' and 'relativeTop'. Either include them or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setLeft' needs the current value of 'relativeLeft'.",["188"],"'Graph' is defined but never used.","'Trie' is defined but never used.","'byLabel' is assigned a value but never used.","'values' is assigned a value but never used.","'node' is assigned a value but never used.","strict","'use strict' is unnecessary inside of modules.","ExpressionStatement","module",{"range":"189","text":"190"},"'HORIZONTAL_DISTANCE' is defined but never used.","'getHash' is defined but never used.","'length' is defined but never used.","'rotate' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"191","fix":"192"},{"messageId":"193","fix":"194","desc":"195"},{"messageId":"196","fix":"197","desc":"198"},{"desc":"199","fix":"200"},[0,13],"","Update the dependencies array to be: [parser, text]",{"range":"201","text":"202"},"removeEscape",{"range":"203","text":"190"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"204","text":"205"},"Replace the `\\` with `\\\\` to include the actual backslash character.","Update the dependencies array to be: [dragging, relativeLeft, relativeTop]",{"range":"206","text":"207"},[3860,3866],"[parser, text]",[2029,2030],[2029,2029],"\\",[1610,1620],"[dragging, relativeLeft, relativeTop]"]